From bafee58abf6ba44d04fe32dfdb1bab18d60fba63 Mon Sep 17 00:00:00 2001
From: Stanislav Ochotnicky <sochotnicky@redhat.com>
Date: Mon, 30 Jan 2012 13:22:34 +0100
Subject: [PATCH] Fix gmime

---
 notmuch-client.h |    4 +-
 notmuch-reply.c  |    5 +--
 notmuch-show.c   |   83 +++++++++++++++++++++++++++--------------------------
 show-message.c   |   27 +++++++----------
 4 files changed, 56 insertions(+), 63 deletions(-)

diff --git a/notmuch-client.h b/notmuch-client.h
index c602e2e..371aef9 100644
--- a/notmuch-client.h
+++ b/notmuch-client.h
@@ -69,7 +69,7 @@ typedef struct notmuch_show_format {
     void (*part_start) (GMimeObject *part,
 			int *part_count);
     void (*part_encstatus) (int status);
-    void (*part_sigstatus) (const GMimeSignatureValidity* validity);
+    void (*part_sigstatus) (GMimeSignatureList *siglist);
     void (*part_content) (GMimeObject *part);
     void (*part_end) (GMimeObject *part);
     const char *part_sep;
@@ -83,7 +83,7 @@ typedef struct notmuch_show_params {
     int entire_thread;
     int raw;
     int part;
-    GMimeCipherContext* cryptoctx;
+    GMimeCryptoContext* cryptoctx;
     int decrypt;
 } notmuch_show_params_t;
 
diff --git a/notmuch-reply.c b/notmuch-reply.c
index 7242310..bfc8868 100644
--- a/notmuch-reply.c
+++ b/notmuch-reply.c
@@ -645,15 +645,12 @@ notmuch_reply_command (void *ctx, int argc, char *argv[])
 	    }
 	} else if ((STRNCMP_LITERAL (argv[i], "--decrypt") == 0)) {
 	    if (params.cryptoctx == NULL) {
-		GMimeSession* session = g_object_new(g_mime_session_get_type(), NULL);
-		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(session, "gpg"))) {
+		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(NULL, "gpg"))) {
 		    fprintf (stderr, "Failed to construct gpg context.\n");
 		} else {
 		    params.decrypt = TRUE;
 		    g_mime_gpg_context_set_always_trust((GMimeGpgContext*)params.cryptoctx, FALSE);
 		}
-		g_object_unref (session);
-		session = NULL;
 	    }
 	} else {
 	    fprintf (stderr, "Unrecognized option: %s\n", argv[i]);
diff --git a/notmuch-show.c b/notmuch-show.c
index 19fb49f..58f9f43 100644
--- a/notmuch-show.c
+++ b/notmuch-show.c
@@ -76,7 +76,7 @@ static void
 format_part_encstatus_json (int status);
 
 static void
-format_part_sigstatus_json (const GMimeSignatureValidity* validity);
+format_part_sigstatus_json (GMimeSignatureList *siglist);
 
 static void
 format_part_content_json (GMimeObject *part);
@@ -487,16 +487,14 @@ show_text_part_content (GMimeObject *part, GMimeStream *stream_out)
 }
 
 static const char*
-signer_status_to_string (GMimeSignerStatus x)
+signature_status_to_string (GMimeSignatureStatus x)
 {
     switch (x) {
-    case GMIME_SIGNER_STATUS_NONE:
-	return "none";
-    case GMIME_SIGNER_STATUS_GOOD:
+    case GMIME_SIGNATURE_STATUS_GOOD:
 	return "good";
-    case GMIME_SIGNER_STATUS_BAD:
+    case GMIME_SIGNATURE_STATUS_BAD:
 	return "bad";
-    case GMIME_SIGNER_STATUS_ERROR:
+    case GMIME_SIGNATURE_STATUS_ERROR:
 	return "error";
     }
     return "unknown";
@@ -593,59 +591,65 @@ format_part_encstatus_json (int status)
 }
 
 static void
-format_part_sigstatus_json (const GMimeSignatureValidity* validity)
+format_part_sigstatus_json (GMimeSignatureList *siglist)
 {
     printf (", \"sigstatus\": [");
 
-    if (!validity) {
+    if (!siglist) {
 	printf ("]");
 	return;
     }
 
-    const GMimeSigner *signer = g_mime_signature_validity_get_signers (validity);
-    int first = 1;
     void *ctx_quote = talloc_new (NULL);
+    int i;
+    for (i = 0; i < g_mime_signature_list_length (siglist); ++i) {
+	GMimeSignature *signature = g_mime_signature_list_get_signature (siglist, i);
 
-    while (signer) {
-	if (first)
-	    first = 0;
-	else
+	if (i > 0)
 	    printf (", ");
-
 	printf ("{");
 
 	/* status */
+	GMimeSignatureStatus status = g_mime_signature_get_status (signature);
 	printf ("\"status\": %s",
 		json_quote_str (ctx_quote,
-				signer_status_to_string (signer->status)));
+				signature_status_to_string (status)));
 
-	if (signer->status == GMIME_SIGNER_STATUS_GOOD)
+	GMimeCertificate *certificate = g_mime_signature_get_certificate (signature);
+	if (status == GMIME_SIGNATURE_STATUS_GOOD)
 	{
-	    if (signer->fingerprint)
-		printf (", \"fingerprint\": %s", json_quote_str (ctx_quote, signer->fingerprint));
+	    if (certificate)
+		printf (", \"fingerprint\": %s", json_quote_str (ctx_quote, g_mime_certificate_get_fingerprint (certificate)));
 	    /* these dates are seconds since the epoch; should we
 	     * provide a more human-readable format string? */
-	    if (signer->created)
-		printf (", \"created\": %d", (int) signer->created);
-	    if (signer->expires)
-		printf (", \"expires\": %d", (int) signer->expires);
+	    time_t created = g_mime_signature_get_created (signature);
+	    if (created != -1)
+		printf (", \"created\": %d", (int) created);
+	    time_t expires = g_mime_signature_get_expires (signature);
+	    if (expires != -1)
+		printf (", \"expires\": %d", (int) expires);
 	    /* output user id only if validity is FULL or ULTIMATE. */
 	    /* note that gmime is using the term "trust" here, which
 	     * is WRONG.  It's actually user id "validity". */
-	    if ((signer->name) && (signer->trust)) {
-		if ((signer->trust == GMIME_SIGNER_TRUST_FULLY) || (signer->trust == GMIME_SIGNER_TRUST_ULTIMATE))
-		    printf (", \"userid\": %s", json_quote_str (ctx_quote, signer->name));
+	    if (certificate)
+	    {
+		const char *name = g_mime_certificate_get_issuer_name (certificate);
+		GMimeCertificateTrust trust = g_mime_certificate_get_trust (certificate);
+		if (name && (trust == GMIME_CERTIFICATE_TRUST_FULLY || trust == GMIME_CERTIFICATE_TRUST_ULTIMATE))
+		    printf (", \"userid\": %s", json_quote_str (ctx_quote, name));
            }
-       } else {
-           if (signer->keyid)
-               printf (", \"keyid\": %s", json_quote_str (ctx_quote, signer->keyid));
-       }
-       if (signer->errors != GMIME_SIGNER_ERROR_NONE) {
-           printf (", \"errors\": %x", signer->errors);
-       }
-
-       printf ("}");
-       signer = signer->next;
+	} else if (certificate) {
+	    const char *key_id = g_mime_certificate_get_key_id (certificate);
+	    if (key_id)
+		printf (", \"keyid\": %s", json_quote_str (ctx_quote, key_id));
+	}
+
+	GMimeSignatureError errors = g_mime_signature_get_errors (signature);
+	if (errors != GMIME_SIGNATURE_ERROR_NONE) {
+	    printf (", \"errors\": %x", errors);
+	}
+
+	printf ("}");
     }
 
     printf ("]");
@@ -973,13 +977,10 @@ notmuch_show_command (void *ctx, unused (int argc), unused (char *argv[]))
 	} else if ((STRNCMP_LITERAL (argv[i], "--verify") == 0) ||
 		   (STRNCMP_LITERAL (argv[i], "--decrypt") == 0)) {
 	    if (params.cryptoctx == NULL) {
-		GMimeSession* session = g_object_new(g_mime_session_get_type(), NULL);
-		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(session, "gpg")))
+		if (NULL == (params.cryptoctx = g_mime_gpg_context_new(NULL, "gpg")))
 		    fprintf (stderr, "Failed to construct gpg context.\n");
 		else
 		    g_mime_gpg_context_set_always_trust((GMimeGpgContext*)params.cryptoctx, FALSE);
-		g_object_unref (session);
-		session = NULL;
 	    }
 	    if (STRNCMP_LITERAL (argv[i], "--decrypt") == 0)
 		params.decrypt = 1;
diff --git a/show-message.c b/show-message.c
index d83f04e..beb5a5c 100644
--- a/show-message.c
+++ b/show-message.c
@@ -68,15 +68,16 @@ show_message_part (GMimeObject *part,
 			 g_mime_multipart_get_count (multipart));
 	    } else {
 		GMimeMultipartEncrypted *encrypteddata = GMIME_MULTIPART_ENCRYPTED (part);
-		decryptedpart = g_mime_multipart_encrypted_decrypt (encrypteddata, params->cryptoctx, &err);
+		GMimeDecryptResult *decrypt_result = g_mime_decrypt_result_new ();
+		decryptedpart = g_mime_multipart_encrypted_decrypt (encrypteddata, params->cryptoctx, &decrypt_result, &err);
 		if (decryptedpart) {
 		    if ((selected || state->in_zone) && format->part_encstatus)
 			format->part_encstatus (1);
-		    const GMimeSignatureValidity *sigvalidity = g_mime_multipart_encrypted_get_signature_validity (encrypteddata);
-		    if (!sigvalidity)
-			fprintf (stderr, "Failed to verify signed part: %s\n", (err ? err->message : "no error explanation given"));
+		    GMimeSignatureList *siglist = g_mime_decrypt_result_get_signatures (decrypt_result);
+		    if (!siglist)
+			fprintf (stderr, "Failed to get signatures: %s\n", (err ? err->message : "no error explanation given"));
 		    if ((selected || state->in_zone) && format->part_sigstatus)
-			format->part_sigstatus (sigvalidity);
+			format->part_sigstatus (siglist);
 		} else {
 		    fprintf (stderr, "Failed to decrypt part: %s\n", (err ? err->message : "no error explanation given"));
 		    if ((selected || state->in_zone) && format->part_encstatus)
@@ -92,20 +93,14 @@ show_message_part (GMimeObject *part,
 			 "Error: %d part(s) for a multipart/signed message (should be exactly 2)\n",
 			 g_mime_multipart_get_count (multipart));
 	    } else {
-		/* For some reason the GMimeSignatureValidity returned
-		 * here is not a const (inconsistent with that
-		 * returned by
-		 * g_mime_multipart_encrypted_get_signature_validity,
-		 * and therefore needs to be properly disposed of.
-		 * Hopefully the API will become more consistent. */
-		GMimeSignatureValidity *sigvalidity = g_mime_multipart_signed_verify (GMIME_MULTIPART_SIGNED (part), params->cryptoctx, &err);
-		if (!sigvalidity) {
+		GMimeSignatureList *siglist = g_mime_multipart_signed_verify (GMIME_MULTIPART_SIGNED (part), params->cryptoctx, &err);
+		if (!siglist) {
 		    fprintf (stderr, "Failed to verify signed part: %s\n", (err ? err->message : "no error explanation given"));
 		}
 		if ((selected || state->in_zone) && format->part_sigstatus)
-		    format->part_sigstatus (sigvalidity);
-		if (sigvalidity)
-		    g_mime_signature_validity_free (sigvalidity);
+		    format->part_sigstatus (siglist);
+		if (siglist)
+		    g_object_unref (siglist);
 	    }
 	}
 
-- 
1.7.7.6

